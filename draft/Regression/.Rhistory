Y_vars <- c("ABSDA", "DA_pos", "DA_neg") # Updated Y_vars to distinguish between positive and negative DA2
X_vars <- c("RM")
models <- list() # To store lm models
se_list <- list() # To store robust SEs for each model
for (Y_var in Y_vars) {
for (X_var in X_vars) {
# Define the model formula
formula <- as.formula(paste0(gsub("_pos|_neg", "", Y_var), " ~ RPA + ", X_var, " + LEV + OCF + MTB + ADJROA + LGTA + Age + Big4 + RD + ADV + ESG + GC + Year"))
# Filter data based on the condition (if applicable)
if (Y_var == "DA_pos") {
temp_data <- data[data$DA > 0, ]
} else if (Y_var == "DA_neg") {
temp_data <- data[data$DA < 0, ]
} else {
temp_data <- data
}
# Fit the model with the filtered data
model <- lm(formula, data = temp_data)
# Calculate clustered standard errors
robust_se <- sqrt(diag(vcovCL(model, type = "HC0", cluster = ~Key)))
# Store the model and its robust SE
models[[paste0(Y_var, "_", X_var)]] <- model
se_list[[paste0(Y_var, "_", X_var)]] <- robust_se
}
}
# Output all models in a single table
stargazer(models, type = "html",
se = se_list,
title = "AM-Regression Results with Clustered Standard Errors", out = "AM_A.html")
# RM
#sink("RM.txt")
# Define the different values for Y and X
# Assuming 'data' is your dataframe and 'Key' is your clustering variable
models <- list() # To store lm models
se_list <- list() # To store robust SEs for each model
X_vars <- c("ABSDA2")
Y_vars <- c("RM1","RM2")
for (Y_var in Y_vars) {
for (X_var in X_vars) {
# Define the model formula
formula <- as.formula(paste0(Y_var, " ~ RPA + ", X_var, " + LEV + OCF + MTB + ADJROA + LGTA + Age + Big4 + RD + ADV + ESG + GC + Year"))
# Fit the model
model <- lm(formula, data = data)
# Calculate clustered standard errors
robust_se <- sqrt(diag(vcovCL(model, type = "HC0", cluster = ~Key)))
# Store the model and its robust SE
models[[paste0(Y_var, "_", X_var)]] <- model
se_list[[paste0(Y_var, "_", X_var)]] <- robust_se
}
}
# Assuming you want to output all models in a single table
stargazer(models, type = "html",
se = se_list,
title = "RM-Regression Results with Clustered Standard Errors", out = "RM2.html")
library(sandwich)
library(lmtest)
library(MASS)
library(dplyr)
library(stargazer)
# 讀取 CSV 檔案，將 "#N/A" 轉換為真正的 NA（缺失值）
data <- read.csv("Total.csv")
# 移除含有缺失值的觀測值
data$ABSDA<-abs(data$DA)
data$ABSDA1<-abs(data$DA1)
data$ABSDA2<-abs(data$DA2)
data$ABSDA3<-abs(data$DA3)
data$RM<-data$ABCFO+data$ABEXP-data$ABPROD
data$RM1<-data$ABCFO+data$ABEXP
data$RM2<--data$ABPROD+data$ABEXP
#data<-subset(data,data$DA2<0)
########### winsorizing 1%
# Define a function for winsorizing
winsorize <- function(x) {
p1 <- quantile(x, probs = 0.01)  # 1st percentile value
p99 <- quantile(x, probs = 0.99)  # 99th percentile value
x[x < p1] <- p1  # Replace values below 1st percentile
x[x > p99] <- p99  # Replace values above 99th percentile
return(x)
}
# Factorize the first 6 columns
data[1:8] <- lapply(data[1:8], factor)
# Apply the winsorize function to the remaining columns
data <- data %>%
mutate(across(.cols = 9:ncol(data), .fns = ~winsorize(.)))
#Now, perform the Huber regression or any regression analysis using winsorized variables+ Year + Industry
#AM
#sink("AM_N.txt")
# Define the different values for Y and X
models <- list() # To store lm models
se_list <- list() # To store robust SEs for each model
Y_vars <- c("ABSDA", "DA_pos", "DA_neg") # Updated Y_vars to distinguish between positive and negative DA2
X_vars <- c("RM")
models <- list() # To store lm models
se_list <- list() # To store robust SEs for each model
for (Y_var in Y_vars) {
for (X_var in X_vars) {
# Define the model formula
formula <- as.formula(paste0(gsub("_pos|_neg", "", Y_var), " ~ RPA + ", X_var, " + LEV + OCF + MTB + ADJROA + LGTA + Age + Big4 + RD + ADV + ESG + GC + Year"))
# Filter data based on the condition (if applicable)
if (Y_var == "DA_pos") {
temp_data <- data[data$DA > 0, ]
} else if (Y_var == "DA_neg") {
temp_data <- data[data$DA < 0, ]
} else {
temp_data <- data
}
# Fit the model with the filtered data
model <- lm(formula, data = temp_data)
# Calculate clustered standard errors
robust_se <- sqrt(diag(vcovCL(model, type = "HC0", cluster = ~Key)))
# Store the model and its robust SE
models[[paste0(Y_var, "_", X_var)]] <- model
se_list[[paste0(Y_var, "_", X_var)]] <- robust_se
}
}
# Output all models in a single table
stargazer(models, type = "html",
se = se_list,
title = "AM-Regression Results with Clustered Standard Errors", out = "AM_A.html")
# RM
#sink("RM.txt")
# Define the different values for Y and X
# Assuming 'data' is your dataframe and 'Key' is your clustering variable
models <- list() # To store lm models
se_list <- list() # To store robust SEs for each model
X_vars <- c("ABSDA2")
Y_vars <- c("RM1","RM2")
for (Y_var in Y_vars) {
for (X_var in X_vars) {
# Define the model formula
formula <- as.formula(paste0(Y_var, " ~ RPA + ", X_var, " + LEV + OCF + MTB + ADJROA + LGTA + Age + Big4 + RD + ADV + ESG + GC + Year"))
# Fit the model
model <- lm(formula, data = data)
# Calculate clustered standard errors
robust_se <- sqrt(diag(vcovCL(model, type = "HC0", cluster = ~Key)))
# Store the model and its robust SE
models[[paste0(Y_var, "_", X_var)]] <- model
se_list[[paste0(Y_var, "_", X_var)]] <- robust_se
}
}
# Assuming you want to output all models in a single table
stargazer(models, type = "html",
se = se_list,
title = "RM-Regression Results with Clustered Standard Errors", out = "RM_A.html")
library(sandwich)
library(lmtest)
library(MASS)
library(dplyr)
library(stargazer)
# 讀取 CSV 檔案，將 "#N/A" 轉換為真正的 NA（缺失值）
data <- read.csv("Total.csv")
# 移除含有缺失值的觀測值
data$ABSDA<-abs(data$DA)
data$ABSDA1<-abs(data$DA1)
data$ABSDA2<-abs(data$DA2)
data$ABSDA3<-abs(data$DA3)
data$RM<-data$ABCFO+data$ABEXP-data$ABPROD
data$RM1<-data$ABCFO+data$ABEXP
data$RM2<-data$ABPROD-data$ABEXP
#data<-subset(data,data$DA2<0)
########### winsorizing 1%
# Define a function for winsorizing
winsorize <- function(x) {
p1 <- quantile(x, probs = 0.01)  # 1st percentile value
p99 <- quantile(x, probs = 0.99)  # 99th percentile value
x[x < p1] <- p1  # Replace values below 1st percentile
x[x > p99] <- p99  # Replace values above 99th percentile
return(x)
}
# Factorize the first 6 columns
data[1:8] <- lapply(data[1:8], factor)
# Apply the winsorize function to the remaining columns
data <- data %>%
mutate(across(.cols = 9:ncol(data), .fns = ~winsorize(.)))
mydata<-data[,c("ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
stargazer(mydata, type = "html", title="Descriptive statistics", digits=5, out="des.html",summary.stat = c("mean","median","sd","min","max","p25","p75","n"))
install.packages("corrtable")
library(sandwich)
library(lmtest)
library(MASS)
library(dplyr)
library(stargazer)
library(corrtable)
library(sandwich)
library(lmtest)
library(MASS)
library(dplyr)
library(stargazer)
library(corrtable)
# 讀取 CSV 檔案，將 "#N/A" 轉換為真正的 NA（缺失值）
data <- read.csv("Total.csv")
# 移除含有缺失值的觀測值
data$ABSDA<-abs(data$DA)
data$ABSDA1<-abs(data$DA1)
data$ABSDA2<-abs(data$DA2)
data$ABSDA3<-abs(data$DA3)
data$RM<-data$ABCFO+data$ABEXP-data$ABPROD
#data<-subset(data,data$DA2<0)
########### winsorizing 1%
# Define a function for winsorizing
winsorize <- function(x) {
p1 <- quantile(x, probs = 0.01)  # 1st percentile value
p99 <- quantile(x, probs = 0.99)  # 99th percentile value
x[x < p1] <- p1  # Replace values below 1st percentile
x[x > p99] <- p99  # Replace values above 99th percentile
return(x)
}
# Factorize the first 6 columns
data[1:8] <- lapply(data[1:8], factor)
# Apply the winsorize function to the remaining columns
data <- data %>%
mutate(across(.cols = 9:ncol(data), .fns = ~winsorize(.)))
mydata<-data[,c("ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
stargazer(mydata, type = "html", title="Descriptive statistics", digits=5, out="des.html",summary.stat = c("mean","median","sd","min","max","p25","p75","n"))
correlation.matrix <- correlation_matrix(mydata,type="pearson",show_significance = TRUE)
stargazer(correlation.matrix,type="html", title="Correlation Matrix")
library(sandwich)
library(lmtest)
library(MASS)
library(dplyr)
library(stargazer)
library(corrtable)
# 讀取 CSV 檔案，將 "#N/A" 轉換為真正的 NA（缺失值）
data <- read.csv("Total.csv")
# 移除含有缺失值的觀測值
data$ABSDA<-abs(data$DA)
data$ABSDA1<-abs(data$DA1)
data$ABSDA2<-abs(data$DA2)
data$ABSDA3<-abs(data$DA3)
data$RM<-data$ABCFO+data$ABEXP-data$ABPROD
#data<-subset(data,data$DA2<0)
########### winsorizing 1%
# Define a function for winsorizing
winsorize <- function(x) {
p1 <- quantile(x, probs = 0.01)  # 1st percentile value
p99 <- quantile(x, probs = 0.99)  # 99th percentile value
x[x < p1] <- p1  # Replace values below 1st percentile
x[x > p99] <- p99  # Replace values above 99th percentile
return(x)
}
# Factorize the first 6 columns
data[1:8] <- lapply(data[1:8], factor)
# Apply the winsorize function to the remaining columns
data <- data %>%
mutate(across(.cols = 9:ncol(data), .fns = ~winsorize(.)))
mydata<-data[,c("ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
stargazer(mydata, type = "html", title="Descriptive statistics", digits=5, out="des1.html",summary.stat = c("mean","median","sd","min","max","p25","p75","n"))
correlation.matrix <- correlation_matrix(mydata,type="pearson",show_significance = TRUE)
stargazer(correlation.matrix,type="html", title="Correlation Matrix",out="des2.html")
library(sandwich)
library(lmtest)
library(MASS)
library(dplyr)
library(stargazer)
library(corrtable)
# 讀取 CSV 檔案，將 "#N/A" 轉換為真正的 NA（缺失值）
data <- read.csv("Total.csv")
# 移除含有缺失值的觀測值
data$ABSDA<-abs(data$DA)
data$ABSDA1<-abs(data$DA1)
data$ABSDA2<-abs(data$DA2)
data$ABSDA3<-abs(data$DA3)
data$RM<-data$ABCFO+data$ABEXP-data$ABPROD
#data<-subset(data,data$DA2<0)
########### winsorizing 1%
# Define a function for winsorizing
winsorize <- function(x) {
p1 <- quantile(x, probs = 0.01)  # 1st percentile value
p99 <- quantile(x, probs = 0.99)  # 99th percentile value
x[x < p1] <- p1  # Replace values below 1st percentile
x[x > p99] <- p99  # Replace values above 99th percentile
return(x)
}
# Factorize the first 6 columns
data[1:8] <- lapply(data[1:8], factor)
# Apply the winsorize function to the remaining columns
data <- data %>%
mutate(across(.cols = 9:ncol(data), .fns = ~winsorize(.)))
mydata<-data[,c("ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
stargazer(mydata, type = "html", title="Descriptive statistics", digits=5, out="des1.html",summary.stat = c("mean","median","sd","min","max","p25","p75","n"))
correlation.matrix <- correlation_matrix(mydata,type="spearman",use = "lower",show_significance = TRUE)
stargazer(correlation.matrix,type="html", title="Correlation Matrix",out="des2.html")
library(sandwich)
library(lmtest)
library(MASS)
library(dplyr)
library(stargazer)
library(corrtable)
# 讀取 CSV 檔案，將 "#N/A" 轉換為真正的 NA（缺失值）
data <- read.csv("Total.csv")
# 移除含有缺失值的觀測值
data$ABSDA<-abs(data$DA)
data$ABSDA1<-abs(data$DA1)
data$ABSDA2<-abs(data$DA2)
data$ABSDA3<-abs(data$DA3)
data$RM<-data$ABCFO+data$ABEXP-data$ABPROD
#data<-subset(data,data$DA2<0)
########### winsorizing 1%
# Define a function for winsorizing
winsorize <- function(x) {
p1 <- quantile(x, probs = 0.01)  # 1st percentile value
p99 <- quantile(x, probs = 0.99)  # 99th percentile value
x[x < p1] <- p1  # Replace values below 1st percentile
x[x > p99] <- p99  # Replace values above 99th percentile
return(x)
}
# Factorize the first 6 columns
data[1:8] <- lapply(data[1:8], factor)
# Apply the winsorize function to the remaining columns
data <- data %>%
mutate(across(.cols = 9:ncol(data), .fns = ~winsorize(.)))
mydata<-data[,c("ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
stargazer(mydata, type = "html", title="Descriptive statistics", digits=5, out="des1.html",summary.stat = c("mean","median","sd","min","max","p25","p75","n"))
correlation.matrix <- correlation_matrix(mydata,type="spearman",use = "lower",show_significance = TRUE,digits = 3)
stargazer(correlation.matrix,type="html", title="Correlation Matrix",out="des2.html")
library(sandwich)
library(lmtest)
library(MASS)
library(dplyr)
library(stargazer)
library(corrtable)
# 讀取 CSV 檔案，將 "#N/A" 轉換為真正的 NA（缺失值）
data <- read.csv("Total.csv")
# 移除含有缺失值的觀測值
data$ABSDA<-abs(data$DA)
data$ABSDA1<-abs(data$DA1)
data$ABSDA2<-abs(data$DA2)
data$ABSDA3<-abs(data$DA3)
data$RM<-data$ABCFO+data$ABEXP-data$ABPROD
#data<-subset(data,data$DA2<0)
########### winsorizing 1%
# Define a function for winsorizing
winsorize <- function(x) {
p1 <- quantile(x, probs = 0.01)  # 1st percentile value
p99 <- quantile(x, probs = 0.99)  # 99th percentile value
x[x < p1] <- p1  # Replace values below 1st percentile
x[x > p99] <- p99  # Replace values above 99th percentile
return(x)
}
# Factorize the first 6 columns
data[1:8] <- lapply(data[1:8], factor)
# Apply the winsorize function to the remaining columns
data <- data %>%
mutate(across(.cols = 9:ncol(data), .fns = ~winsorize(.)))
# Des1
mydata<-data[,c("ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
stargazer(mydata, type = "html", title="Descriptive statistics", digits=5, out="des1.html",summary.stat = c("mean","median","sd","min","max","p25","p75","n"))
#Des2
correlation.matrix <- correlation_matrix(mydata,type="spearman",use = "lower",show_significance = TRUE,digits = 3)
stargazer(correlation.matrix,type="html", title="Correlation Matrix",out="des2.html")
#Des3
mydata2<-data[,c("RPA","ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
# Calculate descriptive statistics
descriptive_stats <- mydata2 %>%
group_by(RPA) %>%
summarise(across(-group_cols(), list(mean = mean, median = median, sd = sd, IQR = IQR), .names = "{.fn}_{.col}"),
.groups = 'drop')
#Des3
mydata2<-data[,c("RPA","ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
# Calculate descriptive statistics
descriptive_stats <- mydata2 %>%
group_by(RPA) %>%
summarise(across(-group_cols(), list(mean = mean, median = median, sd = sd, IQR = IQR), .names = "{.fn}_{.col}"),
.groups = 'drop')
#Des3
mydata2<-data[,c("RPA","ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
# Calculate descriptive statistics
# Calculate descriptive statistics
descriptive_stats <- mydata2 %>%
group_by(RPA) %>%
summarise(across(c("ABSDA2", "DA2", "ABCFO", "ABPROD", "ABEXP", "RM", "ADJROA", "Age", "RD", "ADV", "ESG", "MTB", "OCF", "LEV", "LGTA"),
list(Mean = mean, Median = median, SD = sd, Min = min, Max = max, IQR = IQR), .names = "{.col}_{.fn}"))
# Perform Wilcoxon rank-sum tests for each variable and collect p-values
wilcox_p_values <- sapply(names(mydata2)[-1], function(var) {
test_result <- wilcox.test(as.formula(paste0(var, "~ RPA")), data = mydata2)
return(test_result$p.value)
})
# Prepare a vector for additional lines in stargazer with Wilcoxon test results
additional_lines <- lapply(names(wilcox_p_values), function(var) {
c(var, sprintf("Wilcoxon p = %.5f", wilcox_p_values[var]))
})
# Convert additional_lines to a format stargazer can accept
additional_lines_matrix <- do.call(rbind, additional_lines)
# Use stargazer to generate the table
stargazer(descriptive_stats, type = "html", out="des3.html", title = "Descriptive Statistics by RPA Group",
add.lines = additional_lines_matrix)
library(sandwich)
library(lmtest)
library(MASS)
library(dplyr)
library(stargazer)
library(corrtable)
# 讀取 CSV 檔案，將 "#N/A" 轉換為真正的 NA（缺失值）
data <- read.csv("Total.csv")
# 移除含有缺失值的觀測值
data$ABSDA<-abs(data$DA)
data$ABSDA1<-abs(data$DA1)
data$ABSDA2<-abs(data$DA2)
data$ABSDA3<-abs(data$DA3)
data$RM<-data$ABCFO+data$ABEXP-data$ABPROD
#data<-subset(data,data$DA2<0)
########### winsorizing 1%
# Define a function for winsorizing
winsorize <- function(x) {
p1 <- quantile(x, probs = 0.01)  # 1st percentile value
p99 <- quantile(x, probs = 0.99)  # 99th percentile value
x[x < p1] <- p1  # Replace values below 1st percentile
x[x > p99] <- p99  # Replace values above 99th percentile
return(x)
}
# Factorize the first 6 columns
data[1:8] <- lapply(data[1:8], factor)
# Apply the winsorize function to the remaining columns
data <- data %>%
mutate(across(.cols = 9:ncol(data), .fns = ~winsorize(.)))
# Des1
mydata<-data[,c("ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
stargazer(mydata, type = "html", title="Descriptive statistics", digits=5, out="des1.html",summary.stat = c("mean","median","sd","min","max","p25","p75","n"))
#Des2
correlation.matrix <- correlation_matrix(mydata,type="spearman",use = "lower",show_significance = TRUE,digits = 3)
stargazer(correlation.matrix,type="html", title="Correlation Matrix",out="des2.html")
#Des3
mydata2<-data[,c("RPA","ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
# Calculate descriptive statistics
# Calculate descriptive statistics
descriptive_stats <- mydata2 %>%
group_by(RPA) %>%
summarise(across(c("ABSDA2", "DA2", "ABCFO", "ABPROD", "ABEXP", "RM", "ADJROA", "Age", "RD", "ADV", "ESG", "MTB", "OCF", "LEV", "LGTA"),
list(Mean = mean, Median = median, SD = sd, Min = min, Max = max, IQR = IQR), .names = "{.col}_{.fn}"))
# Perform Wilcoxon rank-sum tests for each variable and collect p-values
wilcox_p_values <- sapply(names(mydata2)[-1], function(var) {
test_result <- wilcox.test(as.formula(paste0(var, "~ RPA")), data = mydata2)
return(test_result$p.value)
})
# Prepare a vector for additional lines in stargazer with Wilcoxon test results
additional_lines <- lapply(names(wilcox_p_values), function(var) {
c(var, sprintf("Wilcoxon p = %.5f", wilcox_p_values[var]))
})
# Convert additional_lines to a format stargazer can accept
additional_lines_matrix <- do.call(rbind, additional_lines)
# Use stargazer to generate the table
stargazer(descriptive_stats, type = "html", out="des3.html", title = "Descriptive Statistics by RPA Group",
add.lines = additional_lines_matrix)
#Des3
mydata2<-data[,c("RPA","ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
# Calculate Descriptive Statistics without using `across()` if causing issues
descriptive_stats <- mydata2 %>%
group_by(RPA) %>%
summarise(
Mean_ABSDA2 = mean(ABSDA2, na.rm = TRUE),
SD_ABSDA2 = sd(ABSDA2, na.rm = TRUE),
# Repeat for other variables as needed...
.groups = 'drop'
)
# Calculate Wilcoxon Test p-values for each variable
wilcox_p_values <- sapply(variables, function(var) {
test <- wilcox.test(as.formula(paste(var, "~ RPA")), data = mydata2)
test$p.value
})
#Des3
mydata2<-data[,c("RPA","ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
# Prepare descriptive statistics for each variable by RPA group
descriptive_stats <- mydata2 %>%
group_by(RPA) %>%
summarise(across(c("ABSDA2", "DA2", "ABCFO", "ABPROD", "ABEXP", "RM", "ADJROA", "Age", "RD", "ADV", "ESG", "MTB", "OCF", "LEV", "LGTA"),
list(mean = ~mean(.x, na.rm = TRUE),
sd = ~sd(.x, na.rm = TRUE)),
.names = "{.col}_{.fn}"),
.groups = 'drop')
# Convert descriptive stats into a wider format for easier handling in stargazer
descriptive_stats_wide <- pivot_wider(descriptive_stats, names_from = name, values_from = value)
library(tidyr)
#Des3
mydata2<-data[,c("RPA","ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
# Prepare descriptive statistics for each variable by RPA group
descriptive_stats <- mydata2 %>%
group_by(RPA) %>%
summarise(across(c("ABSDA2", "DA2", "ABCFO", "ABPROD", "ABEXP", "RM", "ADJROA", "Age", "RD", "ADV", "ESG", "MTB", "OCF", "LEV", "LGTA"),
list(mean = ~mean(.x, na.rm = TRUE),
sd = ~sd(.x, na.rm = TRUE)),
.names = "{.col}_{.fn}"),
.groups = 'drop')
# Convert descriptive stats into a wider format for easier handling in stargazer
descriptive_stats_wide <- pivot_wider(descriptive_stats, names_from = name, values_from = value)
#Des3
mydata2<-data[,c("RPA","ABSDA2","DA2","ABCFO","ABPROD","ABEXP","RM","ADJROA","Age","RD","ADV","ESG","MTB","OCF","LEV","LGTA")]
# Prepare descriptive statistics for each variable by RPA group
descriptive_stats <- mydata2 %>%
group_by(RPA) %>%
summarise(across(c("ABSDA2", "DA2", "ABCFO", "ABPROD", "ABEXP", "RM", "ADJROA", "Age", "RD", "ADV", "ESG", "MTB", "OCF", "LEV", "LGTA"),
list(mean = ~mean(.x, na.rm = TRUE),
sd = ~sd(.x, na.rm = TRUE)),
.names = "{.col}_{.fn}"),
.groups = 'drop')
# Example step to get data in long format if not already
descriptive_stats_long <- descriptive_stats %>%
pivot_longer(cols = -RPA, names_to = "name", values_to = "value")
# Now, use pivot_wider() with the correct column names from the long format
descriptive_stats_wide <- pivot_wider(descriptive_stats_long, names_from = name, values_from = value)
# Perform Wilcoxon rank-sum tests for each variable and collect p-values
wilcox_p_values <- sapply(select(mydata2, -RPA), function(x) {
wilcox.test(x ~ mydata2$RPA)$p.value
})
names(wilcox_p_values) <- names(select(mydata2, -RPA))
# Prepare additional lines for stargazer containing Wilcoxon p-values
additional_lines <- lapply(names(wilcox_p_values), function(var) {
c(var, sprintf("p = %.5f", wilcox_p_values[var]))
})
# Use stargazer to output the descriptive statistics table, manually appending Wilcoxon p-values
stargazer(descriptive_stats_wide, type = "text",
title = "Descriptive Statistics by RPA Group",
add.lines = additional_lines)
